EventBus : 이벤트기반 아키텍쳐
1. 이벤트 클래스 : 다양한 이벤트 유형을 정의하는 기본 클래스
2. 리스너(또는 핸들러) : 특정 이벤트를 수신하고 처리하는 객체
3. 이벤트 버스 클래스 : 이벤트를 등록하고, 이벤틀 발생 시 적절한 리스터에게 전달하는 역할

1)이벤트클래스
모든 이벤트의 기본이 되는 Event클래스를 정의한다.
//Event.h
#ifndef EVENT_H
#define EVENT_H

// Event class
// 모튼 이벤트의 기본 클래스입니다.
// 이 클래스를 통해 다양한 이벤트를 정의할 수 있습니다.
class Event {
public:
	// 가상 소멸자는 객체가 삭제될 때 자원을 적절히 해제할 수 있도록 합니다.
	// default : 컴파일러가 기본 소멸자의 기본 구현을 자동으로 생성하도록 지시한다.
	// 소멸자가 필요할 때 컴파일러가 기본 동작을 수행하도록 한다.
  //다형성과 동적 할당된 객체의 올바른 소멸을 보장하기 위함으로
  //기본클래스에서 가상 소멸자를 정의하면 파생 클래스의 객체가 소멸될
  //때 올바른 소멸자가 호출된다.
  //만약 가상 소멸자를 선언하지 않거나 기본 소멸자를 사용한다면, 파생 클래스의 소멸자
  //호출할 때 메모리 누수가 발생할 수 있습니다. 가상소멸자를 사용하여 파생클래스의 
  //소멸자가 올바르게 호출되도록 하는 것이 좋다.
	virtual ~Event() = default;

	//순수가상함수로 각 파생 클래스에서 이 메서드를 구현해야만함을 알려줍니다.
  //이벤트의 이름을 반환하는 역할을 합니다. 
  //const char* : 함수의 반환형을 나타냅니다. 호출된 곳에서 반환된 문자열을 
  //변경하지 않겠다는 것을 의미한다. 즉, 반환된 문자열을 수정할 수 없을을 나타
  //const : 멤버 함수의 상수성을 나타냅니다. 해당 함수는 객체의 내부 상태를 
  //변경하지 않는 다는 것을 보장한다. 즉, 함수 내에서는 멤버 변수를 수정할 수 
  //없습니다. 이러한 함수는 상수 객체에 대해서도 호출 될 수 있습니다.
  //객체의 상태를 변경하지 않기 때문에 여러 스레드에서 안전하게 사용될 수 있습니다.
	virtual const char* getName() const = 0;
};

#endif // EVENT_H

<=default의 의미와 역할>
-의미 : 컴파일러가 해당 멤버 함수의 기본 구현을 제공하게 합니다.
-역할 : 기본 소멸자, 복사 생성자, 이동 생성자, 복사 대입 연산자, 이동 대입 연산자 등
을 명시적으로 선언하여 사용자가 직접 구현할 필요 없이 컴파일러가 자동으로 제공하는 
기본 기능을 사용할 수 있게 합니다.
이러한 문법은 코드의 가독성을 높이고, 기본적인 멤버 함수의 구현을 자동화하여 코드의
유지보수성을 높이는데 기여합니다.

<일반소멸자 vs 가상소멸자>
각각 다른 상황에 적합한 상황이 있다. 그러나 일반적으로 가상소멸자를 사용하는 것이 더
안전하고 유연한 방법이다.
가상소멸자는 추가적인 오버헤드를 초래할 수 있으므로, 성능에 민감한 상황에서는 신중히
고려해야한다. 하지만 일반적으로는 가상 소멸자를 사용하여 유연성과 안전성을 확보하는것
이 좋다.
1. 다형성(Polymorphism)을 지원
기본 클래스에 가상 소멸자를 선언하면 파생 클래스에서 필요한 소멸자를 정의할 수 있다.
이것은 동적 할당된 객체를 가리키는 폳인터나 참조를 사용할 때 유용하다.
가상 소멸자가 없으면 파생클래스의 소멸자가 호출되지 않을 수 있다.
2. 자원 누출 방지
가상소멸자를 사용하면 파생 클래스에서 동적으로 할당된 자원을 올바르게 해제할 수 있다.
가상소멸자가 없으면 파생 클래스에서 추가적인 정리 작업을 수행할 수 없으므로 자원 누출
이 발생할 수 있다.
3. 상속 계층 구조의 일관성
일반 소멸자를 사용하면 파생 클래스에서 소멸자를 재정의하는것이 선택사항이며, 
누락될 수 있다. 반면 가상 소멸자를 사용하면 파생클래스에서 소멸자를 구현하는 것이 
예상되므로 일관성이 유지된다.


2)특정이벤트클래스
이벤트의 구체적인 유형을 정의
chass MyEvent : public Event {
public:
  MyEvent(int data) : data(data) {}
  int getData() const { return data; }
  const char* getName() const override { return "MyEvent"; }
private:
  int data;
};

3)리스너 인터페이스
특정 이벤트를 처리하는 인터페이스를 정의한다.
class EventListener {
public:
  virtual ~EventListener() = default;
  virtual void onEvent(const Event& event) = 0;
};

4)이벤트버스클래스
이벤트를 등록하고 전달하는 역할을 하는 클래스
#include <vector>
#include <unordered_map>
#include <functional>
#include <typeindex>

class EventBus{
public:
  template<typename EventType>
  void subscribe(std::function<void(const EventType&)> listener){
    auto& listeners = listenersMap[std::type_index(typeid(eventType))];
    listeners.push_back([listener](const Event& event) {
      listener(static_cast<const EventType&(event));
    });
  }

  void publish(const Event& event){
    auto it = listenersMap.find(sted::type_index(typeid(event)));
    if(it != listenersMap.enD()){
      for(auto& listener : it->second) {
        listener(event);
      }
    }
  }

private:
  std::unordered_map<std::type_index, std::vector<std::function<void(const Event&)>>> listenersMap;
};

5) 사용예제
#include <iostream>

class MyEventListener : public EventListener {
public:
  void onEvent(const Event& event) override{
    if(event.getName() == std::string("MyEvent")){
      const MyEvent& myEvent = static_cast<const MyEvent&>(event);
      std::cout << "Received MyEvent with data: " << myEvent.getData() << std::endl;
    }
  }
};

int main(){
  EventBus bus;
  MyEventListener listener;

  bus.subscribe<MyEvent>([&listener](const MyEvent& event){
    listener.onEvent(event);
  });

  MyEvent event(2);
j bus.publish(event);

  return 0;
}

//결과
Received MyEvent with data: 42
