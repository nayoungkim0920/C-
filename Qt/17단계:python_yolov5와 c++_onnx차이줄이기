<수정사항>
1. python_yolov5와 c++_onnx차이줄이기
인식결과가 차이가나 차이를 줄임
python_yolov5에서는 90%이상 컵인식이 잘되었는데
c++_onnx 정확도가 떨어짐
=>onnxDetectImage.py를 만들어 객체감지확인함(C:/images/cups.jpg의 76%와 바운딩박스 확인)
=>c++프로그램에 적용하여 테스트

<필요한 모듈 설치>
[date] C++에서 날짜와 시간 관련 기능을 제공
C:\>git clone https://github.com/HowardHinnant/date.git
C:\>cd date
C:\date>mkdir build
C:\date>cd build
C:\date\build>cmake -G "Visual Studio 16 2019" ..
-- Configuring done (7.7s)
-- Generating done (0.7s)
-- Build files have been written to: C:/date/build
C:\date\build>cmake --build .

[ONNX (Open Neural Network Exchange)] 머신러닝 모델을 교환하는 데 사용
C:\>git clone https://github.com/onnx/onnx.git
C:\>cd onnx
C:\onnx>mkdir build
C:\onnx>cd build
C:\onnx\build>cmake -G "Visual Studio 16 2019" ..
-- Configuring done (22.4s)
-- Generating done (1.0s)
-- Build files have been written to: C:/onnx/build
C:\onnx\build>cmake --build .
C:\onnx>protoc --proto_path=onnx --cpp_out=build onnx/onnx-operators.proto
=> "C:\onnx\build\onnx\onnx-operators.pb.h", "C:\onnx\build\onnx\onnx-operators.pb.cc" 생성

[onnx.pb.h 생성하기]
C:\>protoc --version
libprotoc 26.1
C:\>protoc --proto_path=C:\onnx\onnx --cpp_out=C:\onnx\onnx C:\onnx\onnx\onnx.proto
=>"C:\onnx\onnx\onnx.pb.h" 생성
심각도	코드	설명	프로젝트	파일	줄	비표시 오류(Suppression) 상태
오류	C1189	#error:  "Protobuf C++ gencode is built with an incompatible version of"	Project1	C:\onnx\onnx\onnx.pb.h	15	
C:\>protoc --version
libprotoc 26.1
C:\>vcpkg list | findstr protobuf
protobuf:x64-windows                              4.25.1#1            Google's language-neutral, platform-neutral, ext...
C:\vcpkg>.\vcpkg remove protobuf:x64-windows
The following packages will be removed:
    protobuf:x64-windows
Removing 1/1 protobuf:x64-windows

protobuf 3점대로 다운그레이드 git으로설치변경
C:\>git clone https://github.com/protocolbuffers/protobuf.git
PS C:\Windows\system32> Remove-Item -Path "C:\protobuf\build" -Recurse -Force(build 폴더가 아카이브로 숨겨있어 삭제)
C:\protobuf>cd cmake
C:\protobuf\cmake>mkdir build
C:\protobuf\cmake>cd build
C:\protobuf\cmake\build>cmake -G "Visual Studio 16 2019" ..
-- Could NOT find ZLIB (missing: ZLIB_LIBRARY ZLIB_INCLUDE_DIR)

ZLIB 라이브러리 설치 version "1.3.1.1"
C:\>git clone https://github.com/madler/zlib.git
C:\>cd zlib
C:\zlib>mkdir build
C:\zlib>cd build
C:\zlib\build>cmake -G "Visual Studio 16 2019" ..
C:\zlib\build>cmake --build .
C:\protobuf\cmake\build>cmake -G "Visual Studio 16 2019" ..
-- Could NOT find ZLIB (missing: ZLIB_LIBRARY ZLIB_INCLUDE_DIR)
CMake Error at tests.cmake:11 (message):
  Cannot find third_party/googletest directory that's needed to build tests.
  If you use git, make sure you have cloned submodules:
    git submodule update --init --recursive
  If instead you want to skip tests, run cmake with:
    cmake -Dprotobuf_BUILD_TESTS=OFF
C:\protobuf>git submodule update --init --recursive
C:\protobuf\cmake\build>cmake -G "Visual Studio 16 2019" -DZLIB_INCLUDE_DIR="C:\zlib" -DZLIB_LIBRARY="C:\zlib\build\Release\zlib.lib" -Dprotobuf_BUILD_TESTS=OFF ..
C:\protobuf\cmake\build>cmake ..
-- Selecting Windows SDK version 10.0.22621.0 to target Windows 10.0.22631.
-- 2
-- 3.20.0.2
-- Configuring done (0.1s)
-- Generating done (0.1s)
-- Build files have been written to: C:/protobuf/cmake/build
protobuf재설치
C:\>git clone https://github.com/protocolbuffers/protobuf.git
C:\>cd protobuf
C:\protobuf>git checkout v26.1
C:\protobuf>mkdir build
C:\protobuf>cd build
C:\protobuf\build>cmake -G "Visual Studio 16 2019" -DZLIB_INCLUDE_DIR="C:\zlib" -DZLIB_LIBRARY="C:\zlib\build\Release\zlib.lib" -Dprotobuf_BUILD_TESTS=OFF ..
CMake Error at third_party/utf8_range/CMakeLists.txt:29 (add_subdirectory):
  The source directory
    C:/protobuf/third_party/abseil-cpp
  does not contain a CMakeLists.txt file.
C:\protobuf>git submodule update --init --recursive
"C:\protobuf\third_party\abseil-cpp"생성
-- Configuring done (12.1s)
-- Generating done (28.8s)
-- Build files have been written to: C:/protobuf/build
C:\protobuf\build>cmake -G "Visual Studio 16 2019" -DZLIB_INCLUDE_DIR="C:\zlib" -DZLIB_LIBRARY="C:\zlib\build\Release\zlib.lib" -Dprotobuf_BUILD_TESTS=OFF ..
C:\protobuf\build>cmake --build .
c:\protobuf\build>protoc --version
libprotoc 26.1

심각도	코드	설명	프로젝트	파일	줄	비표시 오류(Suppression) 상태
오류	C1128	섹션 수가 개체 파일 형식 한도를 초과했습니다. /bigobj를 사용하여 컴파일하십시오.	tests	C:\protobuf\src\google\protobuf\descriptor_unittest.cc	1	
CMakeLists.txt에 추가한 후 빌드
add_compile_options(/bigobj)

openCV빌드
C:\opencv\build>cmake -G "Visual Studio 16 2019" ../sources
C:\opencv\build>cmake --build .
error python path
C:\>python
Python 3.12.3 (tags/v3.12.3:f6650f9, Apr  9 2024, 14:05:25) [MSC v.1938 64 bit (AMD64)] on win32
Type "help", "copyright", "credits" or "license" for more information.
>>> import sys
>>> print(sys.executable)
C:\Users\nayou\AppData\Local\Programs\Python\Python312\python.exe
환경변수 Path에추가
C:\>opencv\build>cmake -G "Visual Studio 16 2019" -DPYTHON3_EXECUTABLE="C:\Users\nayou\AppData\Local\Programs\Python\Python312\python.exe" ../sources
-- Configuring done (153.8s)
-- Generating done (14.8s)
-- Build files have been written to: C:/opencv/build
C:\>opencv\build>cmake --build .
LINK : fatal error LNK1104: 'python312_d.lib' 파일을 열 수 없습니다. [C:\opencv\build\modules\python3\opencv_python3.vcxproj]
C:\opencv\build>cmake -G "Visual Studio 16 2019" ^      -DCMAKE_BUILD_TYPE=Debug ^      -DPYTHON3_EXECUTABLE="C:/Users/nayou/AppData/Local/Programs/Python/Python312/python.exe" ^      -DPYTHON3_LIBRARY="C:/Users/nayou/AppData/Local/Programs/Python/Python312/libs/python312.lib" ^      -DPYTHON3_INCLUDE_DIR="C:/Users/nayou/AppData/Local/Programs/Python/Python312/include" ^      -DOPENCV_EXTRA_MODULES_PATH="C:/opencv_contrib/modules" ^      -DPYTHON3_DEBUG_LIBRARY="C:/Users/nayou/AppData/Local/Programs/Python/Python312/libs/python312.lib" ^      ../sources
C:\opencv\build>cmake --build . --config Debug 

[onnxruntime 설치]
대형 저장소를 클론할 때 --depth 플래그를 사용하여 클론 깊이를 줄일 수 있다.
C:\>git clone --depth 1 https://github.com/microsoft/onnxruntime.git
실패할경우 버퍼를 늘려준다.
git config --global http.postBuffer 1048576000
C:\>cd c:/onnxruntime
c:\onnxruntime>mkdir build
c:\onnxruntime>cd build
c:\onnxruntime\build>cmake -DCMAKE_PREFIX_PATH="C:/onnxruntime" -DCMAKE_BUILD_TYPE=Release ../cmake
c:\onnxruntime\build>cmake -DCMAKE_PREFIX_PATH="C:/onnxruntime" -DCMAKE_BUILD_TYPE=Debug ../cmake
c:\onnxruntime\build>cmake --build . --config Debug
c:\onnxruntime\build>cmake --build . --config Release --DProtobuf_PROTOC_EXECUTABLE="C:/protobuf/build/Release/protoc.exe"
환경변수 Path 에 추가
"C:\protobuf\build\Release\protoc.exe"
C:\protobuf\build\Release
"C:\protobuf\build\Debug\protoc.exe"
C:\protobuf\build\Debug
cmake -DCMAKE_PREFIX_PATH="C:/onnxruntime" -DProtobuf_PROTOC_EXECUTABLE="C:/protobuf/build/Release/protoc.exe" -DCMAKE_BUILD_TYPE=Release ../cmake
cmake -DCMAKE_PREFIX_PATH="C:/onnxruntime" -DProtobuf_PROTOC_EXECUTABLE="C:/protobuf/build/Release/protoc.exe" -DCMAKE_BUILD_TYPE=Debug ../cmake

Visual Studio 2019 개발자 명령프롬프트
C:\onnxruntime\build>del /S /Q CMakeCache.txt CMakeFiles
C:\onnxruntime\build>cmake -G "Visual Studio 16 2019" -DCMAKE_BUILD_TYPE=Release ../cmake
C:\onnxruntime\build>cmake --build . --config Release
C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\MSBuild\Microsoft\VC\v160\Microsoft.CppCommon.targets(241
,5): error MSB8066: 'C:\onnxruntime\build\CMakeFiles\51a714ff5d5f4ddcd911b32bf85404f6\onnx-ml.proto.rule;C:\onnxruntime
\build\CMakeFiles\51a714ff5d5f4ddcd911b32bf85404f6\onnx-ml.pb.cc.rule;C:\onnxruntime\build\CMakeFiles\58447f3a954f50939
f49ca782059b608\gen_onnx_proto.rule'에 대한 사용자 지정 빌드가 종료되었습니다(코드 9009). [C:\onnxruntime\build\_deps\onnx-build\gen_onnx_p
roto.vcxproj]
-환경변수에 다른경로가 지정되있어서 삭제함
C:\onnxruntime\build>del /S /Q CMakeCache.txt CMakeFiles
C:\onnxruntime\build>cmake -G "Visual Studio 16 2019" -DCMAKE_BUILD_TYPE=Release ../cmake
C:\onnxruntime\build>cmake --build . --config Release
환경변수 Path 추가 : C:\zlib\build\Release
C:\onnxruntime\build>cmake --build . --target clean
C:\onnx\build\CMakeFiles\41a20bbd415e2018a37ef4502f9cfc52\onnx-ml.proto.rule
C:\onnx\build\CMakeFiles\41a20bbd415e2018a37ef4502f9cfc52\onnx-ml.pb.cc.rule
C:\onnx\build\CMakeFiles\242e772f96f3d05e3d2fffb145dc6636\gen_onnx_proto.rule

[onnxruntime 재설치]
git clone https://github.com/microsoft/onnxruntime.git
cd onnxruntime
https://github.com/microsoft/onnxruntime/releases
Source code(zip)
onnxruntime-1.18.1.zip
압축을 풀고 c:\onnxruntime 으로 이동
c:\onnxruntime>mkdir build
c:\onnxruntime>cd build
c:\onnxruntime\build>cmake ../cmake -G "Visual Studio 16 2019" -DCMAKE_BUILD_TYPE=Release -DONNX_RUNTIME_BUILD_SHARED_LIB=ON -
cmake ../cmake -G "Visual Studio 16 2019" -DCMAKE_BUILD_TYPE=Release -DONNX_RUNTIME_BUILD_SHARED_LIB=ON -DUSE_PROTOBUF_SHARED_LIBS=ON -DONNX_BUILD_SHARED_LIBS=ON -DBUILD_SHARED_LIBS=ON
C:\Program Files\Microsoft Visual Studio\2022\Enterprise\MSBuild\Microsoft\VC\v170\Microsoft.CppCommon.targets(254,5):
error MSB8066: 'C:\onnxruntime\build\CMakeFiles\51a714ff5d5f4ddcd911b32bf85404f6\onnx-ml.proto.rule;C:\onnxruntime\buil
d\CMakeFiles\51a714ff5d5f4ddcd911b32bf85404f6\onnx-ml.pb.cc.rule;C:\onnxruntime\build\CMakeFiles\58447f3a954f50939f49ca
782059b608\gen_onnx_proto.rule'에 대한 사용자 지정 빌드가 종료되었습니다(코드 9009). [C:\onnxruntime\build\_deps\onnx-build\gen_onnx_proto.
vcxproj]
==>미해결..
재설치( ONNXRUNTIMEConfig.cmake, onnxruntime-config.cmake, share폴더 생성이안됌)
c:\> git clone --recursive https://github.com/microsoft/onnxruntime
c:\>cd onnxruntime
c:\onnxruntime>mkdir build && cd build
C:\onnxruntime\cmake\CMakeLists.txt 추가(옵션에서 설정이 안됨)
#add user##############################################################################
set(protobuf_PROTOC_EXECUTABLE "C:/protobuf/build/Release/protoc.exe" CACHE FILEPATH "Path to protoc executable")
set(Protobuf_INCLUDE_DIR "C:/protobuf/src")
set(Protobuf_LIBRARIES "C:/protobuf/build/Release/libprotobuf.lib")
find_package(Protobuf REQUIRED)
include_directories(${Protobuf_INCLUDE_DIRS})
link_directories(${Protobuf_LIBRARY_DIRS})
#add user##############################################################################
c:\onnxruntime\build>cmake -G "Visual Studio 16 2019" -A x64 -DCMAKE_BUILD_TYPE=Release -DONNX_RUNTIME_BUILD_SHARED_LIB=ON -DCMAKE_INSTALL_PREFIX=./install -DZLIB_INCLUDE_DIR="C:/zlib" ../cmake
c:\onnxruntime\build>cmake --build . --config Release
c:\>git clone https://github.com/google/flatbuffers.git
c:\>cd flatbuffers
c:\flatbuffers>mkdir build
c:\flatbuffers>cd build
c:\flatbuffers/build>cmake ..
c:\flatbuffers/build>cmake --build . --config Release
C:\onnxruntime\cmake\CMakeLists.txt 추가
set(FLATBUFFERS_DIR "C:/flatbuffers/build/Release")
find_package(flatbuffers REQUIRED)
include_directories(${FLATBUFFERS_INCLUDE_DIRS})
link_directories(${FLATBUFFERS_LIBRARY_DIRS})
c:\onnxruntime\build>cmake -G "Visual Studio 16 2019" -A x64 -DCMAKE_BUILD_TYPE=Release -DONNX_RUNTIME_BUILD_SHARED_LIB=ON -DCMAKE_INSTALL_PREFIX=./install -DZLIB_INCLUDE_DIR="C:/zlib" ../cmake
set(CMAKE_PREFIX_PATH "C:/flatbuffers")
set(flatbuffers_DIR "${CMAKE_PREFIX_PATH}/build/Release" "${CMAKE_PREFIX_PATH}/CMake")
find_package(flatbuffers REQUIRED)
include_directories(${flatbuffers_INCLUDE_DIRS})
link_directories(${flatbuffers_LIBRARY_DIRS})
c:\onnxruntime\build>cmake -G "Visual Studio 16 2019" -A x64 -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=./install -DZLIB_INCLUDE_DIR="C:/zlib" ../cmake
-- Configuring done (36.4s)
-- Generating done (22.6s)
-- Build files have been written to: C:/onnxruntime/build
c:\onnxruntime\build>cd C:\abseil-cpp\build
C:\abseil-cpp\build>cmake -G "Visual Studio 16 2019" -A x64 -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=./install -DZLIB_INCLUDE_DIR="C:/zlib" ..
C:\abseil-cpp\build>cmake --build . --config Release
=> C:/Program Files (x86)/absl
C:\protobuf\CMakeLists.txt
##################################################################
set(absl_DIR "C:/abseil-cpp")
find_package(absl REQUIRED)
include_directories(${absl_INCLUDE_DIRS})
link_directories(${absl_LIBRARY_DIRS})
##################################################################
c:\protobuf\build>cmake -G "Visual Studio 16 2019" -A x64 -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=./install -DZLIB_INCLUDE_DIR="C:/zlib" ..
C:\abseil-cpp\absl\log\log.h
#include "absl/log/scoped_mock_log.h" 추가 저장 
(파일이존재해도 absl::scoped_mock_log not found error
"C:\abseil-cpp\absl\log\scoped_mock_log.h")
C:\abseil-cpp\build
C:\abseil-cpp\build>cmake ..
C:\abseil-cpp\build>cmake --build .
C:\abseil-cpp\absl\log\scoped_mock_log.h(27,10): error C1083: 포함 파일을 열 수 없습니다. 'gmock/gmock.h': No such file or directo
ry [C:\abseil-cpp\build\absl\log\die_if_null.vcxproj]
Google Test를 설치하면 Google Mock도 함께 설치해야함
C:\>git clone https://github.com/google/googletest.git
C:\>cd googletest
C:\googletest>mkdir build
C:\googletest>cd build
C:\googletest\build>C:\googletest\build>cmake -G "Visual Studio 16 2019" -A x64 -DCMAKE_INSTALL_PREFIX=./install ..
-- Configuring done (9.0s)
-- Generating done (0.9s)
-- Build files have been written to: C:/googletest/build
C:\googletest\build>cmake --build .
.NET Framework용 Microsoft (R) Build Engine 버전 16.11.2+f32259642
Copyright (C) Microsoft Corporation. All rights reserved.
  gtest-all.cc
  gmock-all.cc
  코드를 생성하고 있습니다...
  gmock.vcxproj -> C:\googletest\build\lib\Debug\gmock.lib
  gtest-all.cc
  gmock-all.cc
  gmock_main.cc
  코드를 생성하고 있습니다...
  gmock_main.vcxproj -> C:\googletest\build\lib\Debug\gmock_main.lib
  gtest-all.cc
  gtest.vcxproj -> C:\googletest\build\lib\Debug\gtest.lib
  gtest_main.cc
  gtest_main.vcxproj -> C:\googletest\build\lib\Debug\gtest_main.lib
C:\googletest\build>cmake --install .
C:\abseil-cpp\build>cmake -G "Visual Studio 16 2019" -A x64 -DCMAKE_INSTALL_PREFIX=./install ..
-- Configuring done (0.3s)
-- Generating done (12.2s)
-- Build files have been written to: C:/abseil-cpp/build
C:\abseil-cpp\build>cmake -G "Visual Studio 16 2019" -A x64 -DCMAKE_INSTALL_PREFIX=./install ..
-- Configuring done (7.4s)
-- Generating done (9.9s)
-- Build files have been written to: C:/abseil-cpp/build
C:\abseil-cpp\build>cmake --build .
C:\abseil-cpp\build>cmake --install . 
c:\protobuf\build>cmake -G "Visual Studio 16 2019" -A x64 -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=./install -DZLIB_INCLUDE_DIR="C:/zlib" ..
[libgtest.lib 및 libgtest_main.lib가 생성되지 않음]
==> gtest.lib, gtest_main.lib 로 이름이 바뀐것같아 대체해보니 잘되었음.
c:\googletest\build>del /S /Q CMakeCache.txt CMakeFiles 
c:\googletest\build>cmake -G "Visual Studio 16 2019" -A x64 ..
c:\googletest\build>cmake --build . --config Release
c:\googletest\build>cmake --install . 
c:\protobuf\build>cmake -G "Visual Studio 16 2019" -A x64 -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=./install -DZLIB_INCLUDE_DIR="C:/zlib" ..
c:\protobuf\build>cmake --build . --config Release
c:\protobuf\build>cmake --install . 
[C:\protobuf\CMakeLists.txt] - 성공!
##################################################################
set(GTEST_INCLUDE_DIR "C:/googletest/include")
set(GTEST_LIBRARY "C:/googletest/build/lib/Release/gtest.lib")
set(GTEST_MAIN_LIBRARY "C:/googletest/build/lib/Release/gtest_main.lib")
include_directories(${GTEST_INCLUDE_DIRS})
link_directories(${GTEST_LIBRARY_DIRS})
include_directories("C:/abseil-cpp/absl")
link_directories("C:/abseil-cpp/build/absl")
##################################################################
C:\myLab\Project1\Project1\build>del /S /Q CMakeCache.txt CMakeFiles
C:\myLab\Project1\Project1\build>cmake -G "Visual Studio 16 2019" -A x64 -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=./install ..
CMake Error at CMakeLists.txt:52 (find_package):
  By not providing "FindONNXRUNTIME.cmake" in CMAKE_MODULE_PATH this project
  has asked CMake to find a package configuration file provided by
  "ONNXRUNTIME", but CMake did not find one.
  Could not find a package configuration file provided by "ONNXRUNTIME" with
  any of the following names:
    ONNXRUNTIMEConfig.cmake
    onnxruntime-config.cmake
  Add the installation prefix of "ONNXRUNTIME" to CMAKE_PREFIX_PATH or set
  "ONNXRUNTIME_DIR" to a directory containing one of the above files.  If
  "ONNXRUNTIME" provides a separate development package or SDK, be sure it
  has been installed.
-- Configuring incomplete, errors occurred!
c:\onnxruntime\build>del /S /Q CMakeCache.txt CMakeFiles 
c:\onnxruntime\build>cmake -G "Visual Studio 16 2019" -A x64 -DZLIB_INCLUDE_DIR="C:/zlib" ../cmake
c:\onnxruntime\build>cmake --build . --config Release
C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\MSBuild\Microsoft\VC\v160\Microsoft.CppCommon.targets(241
,5): error MSB8066: 'C:\onnxruntime\build\CMakeFiles\51a714ff5d5f4ddcd911b32bf85404f6\onnx-ml.proto.rule;C:\onnxruntime
\build\CMakeFiles\51a714ff5d5f4ddcd911b32bf85404f6\onnx-ml.pb.cc.rule;C:\onnxruntime\build\CMakeFiles\58447f3a954f50939
f49ca782059b608\gen_onnx_proto.rule'에 대한 사용자 지정 빌드가 종료되었습니다(코드 9009). 
[C:\onnxruntime\build\_deps\onnx-build\gen_onnx_proto.vcxproj]
c:\onnxruntime\build>cmake --build . --config Release
...
  'C:\yolov5\python'은(는) 내부 또는 외부 명령, 실행할 수 있는 프로그램, 또는
  배치 파일이 아닙니다.
C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\MSBuild\Microsoft\VC\v160\Microso
ft.CppCommon.targets(241,5): error MSB8066: 'C:\onnxruntime\build\CMakeFiles\51a714ff5d5f4ddcd9
11b32bf85404f6\onnx-data.proto.rule;C:\onnxruntime\build\CMakeFiles\51a714ff5d5f4ddcd911b32bf85
404f6\onnx-data.pb.cc.rule;C:\onnxruntime\build\CMakeFiles\58447f3a954f50939f49ca782059b608\gen
_onnx_data_proto.rule'에 대한 사용자 지정 빌드가 종료되었습니다(코드 9009). [C:\onnxruntime\build\_deps\onnx-build\
gen_onnx_data_proto.vcxproj]
  Running gen_proto.py on onnx/onnx-operators.in.proto
  'C:\yolov5\python'은(는) 내부 또는 외부 명령, 실행할 수 있는 프로그램, 또는
  배치 파일이 아닙니다.
C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\MSBuild\Microsoft\VC\v160\Microso
ft.CppCommon.targets(241,5): error MSB8066: 'C:\onnxruntime\build\CMakeFiles\51a714ff5d5f4ddcd9
11b32bf85404f6\onnx-operators-ml.proto.rule;C:\onnxruntime\build\CMakeFiles\51a714ff5d5f4ddcd91
1b32bf85404f6\onnx-operators-ml.pb.cc.rule;C:\onnxruntime\build\CMakeFiles\58447f3a954f50939f49
ca782059b608\gen_onnx_operators_proto.rule'에 대한 사용자 지정 빌드가 종료되었습니다(코드 9009). [C:\onnxruntime\bu
ild\_deps\onnx-build\gen_onnx_operators_proto.vcxproj]
환경변수검색
C:\>echo %PYTHONPATH%
C:\Users\nayou\AppData\Local\Programs\Python\Python312 맞게되어있음
C:\>findstr /s /i "C:\yolov5\python" *.* 어디에설정되있지 몰라 검색함
=>"C:\onnxruntime\build\_deps\onnx-build\gen_onnx_proto.vcxproj" => *.vcxproj 마다 수정정
<Command Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">setlocal
C:\yolov5\python C:/onnxruntime/build/_deps/onnx-src/onnx/gen_proto.py -p onnx -o C:/onnxruntime/build/_deps/onnx-build/onnx onnx -m -l
if %errorlevel% neq 0 goto :cmEnd
:cmEnd
endlocal &amp; call :cmErrorLevel %errorlevel% &amp; goto :cmDone
:cmErrorLevel
exit /b %1
:cmDone
if %errorlevel% neq 0 goto :VCEnd</Command>
C:\yolov5\python => C:\Users\nayou\AppData\Local\Programs\Python\Python312 로 수정
C:\onnxruntime\cmake\CMakeLists.txt
#add user##############################################################################
set(protobuf_PROTOC_EXECUTABLE "C:/protobuf/build/Release/protoc.exe" CACHE FILEPATH "Path to protoc executable")
set(Protobuf_INCLUDE_DIR "C:/protobuf/build/install/include")
set(Protobuf_LIBRARIES "C:/protobuf/build/Release/libprotobuf.lib")
find_package(Protobuf REQUIRED)
include_directories(${Protobuf_INCLUDE_DIRS})
link_directories(${Protobuf_LIBRARY_DIRS})
set(flatbuffers_DIR "C:/flatbuffers/CMake")
set(flatbuffers_INCLUDE_DIRS "C:/flatbuffers/include")
set(flatbuffers_LIBRARY_DIRS "C:/flatbuffers/build/Release")
find_package(flatbuffers REQUIRED)
include_directories(${flatbuffers_INCLUDE_DIRS})
link_directories(${flatbuffers_LIBRARY_DIRS})
#add user##############################################################################
c:\onnxruntime\build>del /S /Q CMakeCache.txt CMakeFiles
c:\onnxruntime\build>cmake -G "Visual Studio 16 2019" -A x64 -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=./install ../cmake
--   Protobuf compiler                 : C:/protobuf/build/Release/protoc.exe
--   Protobuf includes                 : C:/protobuf/build/install/include
--   Protobuf libraries                : C:/protobuf/build/Release/libprotobuf.lib
c:\onnxruntime\build>cmake --build . --config Release

C:\onnxruntime\build\_deps\abseil_cpp-src\absl\synchronization\internal\graphcycles.cc(368,19): error C2039: 'TestO
nlyAddNodes': 'absl::lts_20240116::synchronization_internal::GraphCycles'의 멤버가 아닙니다. [C:\onnxruntime\build\_deps\ab
seil_cpp-build\absl\synchronization\absl_graphcycles_internal.vcxproj]
C:\onnxruntime\build\_deps\abseil_cpp-src\absl\synchronization\internal\graphcycles.cc(369,23): error C2065: 'rep_'
: 선언되지 않은 식별자입니다. [C:\onnxruntime\build\_deps\abseil_cpp-build\absl\synchronization\absl_graphcycles_internal.vcxpr
oj]
C:\onnxruntime\build\_deps\abseil_cpp-src\absl\synchronization\internal\graphcycles.cc(370,3): error C2065: 'rep_':
 선언되지 않은 식별자입니다. [C:\onnxruntime\build\_deps\abseil_cpp-build\absl\synchronization\absl_graphcycles_internal.vcxpro
j]
C:\onnxruntime\build\_deps\abseil_cpp-src\absl\synchronization\internal\graphcycles.cc(372,5): error C2065: 'rep_':
 선언되지 않은 식별자입니다. [C:\onnxruntime\build\_deps\abseil_cpp-build\absl\synchronization\absl_graphcycles_internal.vcxpro
j]
C:\onnxruntime\build\_deps\abseil_cpp-src\absl\hash\internal\hash.cc(64,10): error C3861: 'LowLevelHashLenGt16': 식 별
자를 찾을 수 없습니다. [C:\onnxruntime\build\_deps\abseil_cpp-build\absl\hash\absl_hash.vcxproj]
c:\onnxruntime\build>rd /s /q _deps\abseil_cpp-src
c:\onnxruntime\build>cmake --build . --target download_dependencies --config Release
c:\onnxruntime\build>rd /s /q CMakeFiles
c:\onnxruntime\build>del CMakeCache.txt
c:\onnxruntime\build>cmake ../cmake
-빌드환경정
c:\onnxruntime\build>rd /s /q CMakeFiles
c:\onnxruntime\build>del CMakeCache.txt
c:\onnxruntime\build>del /q /s *.cmake

c:\onnxruntime\build>cmake -G "Visual Studio 16 2019" -DZLIB_INCLUDE_DIR="C:/zlib" -DCMAKE_INSTALL_PREFIX=./install ../cmake 
-- Configuring done (54.1s)
-- Generating done (24.1s)
-- Build files have been written to: C:/onnxruntime/build 
c:\onnxruntime\build>cmake --build . --config Release
Abseil C++ 라이브러리 오류발생..
C:\onnxruntime\build\_deps\abseil_cpp-src\absl\hash\internal\hash.cc(64,10): error C3861: 'LowLevelHashLenGt16': 식 별
자를 찾을 수 없습니다. [C:\onnxruntime\build\_deps\abseil_cpp-build\absl\hash\absl_hash.vcxproj]
....
del /s /q C:\onnxruntime\build\CMakeCache.txt
rd /s /q C:\onnxruntime\build\CMakeFiles
c:\onnxruntime\build>cmake -G "Visual Studio 16 2019" -DZLIB_INCLUDE_DIR="C:/zlib" -DCMAKE_INSTALL_PREFIX=./install ../cmake
c:\onnxruntime\build>cmake --build . --config Release
C:\yolov5\python => C:\Users\nayou\AppData\Local\Programs\Python\Python312\python (몇개의 vcxproj파일마다 바꿔줘야함 한파일당 여러번선언되있음)
onnx.vcxproj -> C:\onnxruntime\build\_deps\onnx-build\Release\onnx.lib
onnxruntime_providers_shared.vcxproj -> C:\onnxruntime\build\Release\onnxruntime_providers_shared.dll
c:\onnxruntime\build>cmake --install .
-- Install configuration: "Release"
CMake Error at cmake_install.cmake:39 (file):
  file INSTALL cannot find
  "C:/onnxruntime/build/Release/onnxruntime_flatbuffers.lib": No error.

c:\onnxruntime\build>cd C:\myLab\Project1\Project1\build
C:\myLab\Project1\Project1\build>rd /s /q CMakeFiles
C:\myLab\Project1\Project1\build>del CMakeCache.txt
C:\myLab\Project1\Project1\build>del /q /s *.cmake
C:\myLab\Project1\Project1\build>cmake -G "Visual Studio 16 2019" -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=./install ..
에러!!
CMake Error at CMakeLists.txt:52 (find_package):
  By not providing "FindONNXRUNTIME.cmake" in CMAKE_MODULE_PATH this project
  has asked CMake to find a package configuration file provided by
  "ONNXRUNTIME", but CMake did not find one.
  Could not find a package configuration file provided by "ONNXRUNTIME" with
  any of the following names:
    ONNXRUNTIMEConfig.cmake
    onnxruntime-config.cmake
  Add the installation prefix of "ONNXRUNTIME" to CMAKE_PREFIX_PATH or set
  "ONNXRUNTIME_DIR" to a directory containing one of the above files.  If
  "ONNXRUNTIME" provides a separate development package or SDK, be sure it
  has been installed.
-- Configuring incomplete, errors occurred!
C:\myLab\Project1\Project1\build>rd /s /q CMakeFiles && del CMakeCache.txt && del /q /s *.cmake
C:\myLab\Project1\Project1\build>cmake -G "Visual Studio 16 2019" -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=./install ..
# ONNX Runtime 설정 - 성공!
set(ONNXRUNTIME_DIR "C:/onnxruntime/build/Release")
include_directories("C:/onnxruntime/include")
link_directories("C:/onnxruntime/build/Release")
-- Could NOT find WrapVulkanHeaders (missing: Vulkan_INCLUDE_DIR)
Vulkan-Headers 설치
C:\>git clone https://github.com/KhronosGroup/Vulkan-Headers.git
C:\Vulkan-Headers>xcopy /E /I include\vulkan "C:\VulkanSDK\Include\vulkan"
Vulkan SDK 설치 (Khronos Group에서 개발한 고성능, 크로스 플랫폼의 그래픽 및 컴퓨팅 API)
https://www.lunarg.com/vulkan-sdk/
VulkanSDK-1.3.290.0-Installer.exe
변수 이름: VULKAN_SDK
변수 값: C:\VulkanSDK\1.3.290.0
PATH 변수에 다음을 추가합니다:
%VULKAN_SDK%\Bin
INCLUDE 변수에 다음을 추가합니다:
%VULKAN_SDK%\Include
LIB 변수에 다음을 추가합니다:
%VULKAN_SDK%\Lib
C:\>xcopy /E /I "C:\Vulkan-Headers\include\vulkan" "C:\VulkanSDK\1.3.290.0\Include\vulkan" 
=> 35개파일카피
C:\myLab\Project1\Project1\CMakeLists.txt
# Vulkan 설정
set(VULKAN_SDK "C:/VulkanSDK/1.3.290.0")
set(VULKAN_BIN "${VULKAN_SDK}/Bin")
set(Vulkan_INCLUDE_DIR "${VULKAN_SDK}/Include")
set(Vulkan_LIBRARY "${VULKAN_SDK}/Lib")
find_package(Vulkan REQUIRED)
message(STATUS "Vulkan INCLUDE found: ${Vulkan_INCLUDE_DIRS}")
message(STATUS "Vulkan LIBRARY found: ${Vulkan_LIBRARIES}")
find_program(GLSLC_EXECUTABLE glslc PATHS ${VULKAN_BIN} NO_DEFAULT_PATH)
if(NOT GLSLC_EXECUTABLE)
    message(FATAL_ERROR "glslc executable not found.")
endif()
성공!
C:\myLab\Project1\Project1\build>cmake --build . --config Release
C:\onnxruntime\include\../include/onnxruntime/core/providers/cpu/cpu_provider_factory.h(4,10): fatal error C1083: 포함  파일
을 열 수 없습니다. 'onnxruntime_c_api.h': No such file or directory [C:\myLab\Project1\Project1\build\Project1.vcxproj]
"C:\onnxruntime\include\onnxruntime\core\session\onnxruntime_c_api.h"
에러체크
-- Check for working CUDA compiler: C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v12.1/bin/nvcc.exe - skipped
C:\myLab\Project1\Project1\build>cmake --version
cmake version 3.29.3
C:\myLab\Project1\Project1\build>"C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v12.1/bin/nvcc.exe" --version
nvcc: NVIDIA (R) Cuda compiler driver
Copyright (c) 2005-2023 NVIDIA Corporation
Built on Wed_Feb__8_05:53:42_Coordinated_Universal_Time_2023
Cuda compilation tools, release 12.1, V12.1.66
Build cuda_12.1.r12.1/compiler.32415258_0
C:\myLab\Project1\Project1\build>cmake --build . --config Release
C:\myLab\Project1\Project1\build>cmake -G "Visual Studio 16 2019" -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=./install ..
find_package(CUDAToolkit REQUIRED cudaarithm cudafilters cudawarping cudacodec cudafeatures2d cudaimgproc)
# Cuda 아키텍처 설정
set(CUDA_TOOLKIT_ROOT_DIR "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v12.1")
set(CUDA_NVCC_EXECUTABLE "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v12.1/bin/nvcc.exe")
set(CUDA_ARCHITECTURES "89")
include_directories("${CUDAToolkit_INCLUDE_DIRS}")
message(STATUS "CUDA Architectures set to: ${CUDA_ARCHITECTURES}")
# CUDA 파일 설정
set(CUDA_NVCC_FLAGS ${CUDA_NVCC_FLAGS} -std=c++20 --expt-relaxed-constexpr -gencode arch=compute_89,code=sm_89)
# CUDA 파일 컴파일 및 라이브러리 생성
cuda_add_library(project1
    imageProcessing.cu
)
# CUDA 컴파일러 경로 확인
if (CUDAToolkit_FOUND)
    message(STATUS "CUDAToolkit_INCLUDE_DIRS: ${CUDAToolkit_INCLUDE_DIRS}")
    message(STATUS "CUDAToolkit_BIN_DIR: ${CUDAToolkit_BIN_DIR}")
    message(STATUS "CUDAToolkit_BIN_DIR: ${CUDAToolkit_VERSION}")
else()
    message(FATAL_ERROR "CUDA Toolkit not found.")
endif()
C:\onnxruntime\onnxruntime/core/providers/cuda/cuda_provider_factory.h(5,10): fatal error C1083: 포함 파일을 열 수 없습 니다. 'core
/framework/provider_options.h': No such file or directory [C:\myLab\Project1\Project1\build\Project1.vcxproj]
[GPU & machinelearnging 설정부터 적용]
C:\myLab\Project1\Project1\build>cmake -G "Visual Studio 16 2019" -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=./install ..
-- Selecting Windows SDK version 10.0.22621.0 to target Windows 10.0.22631.
-- The CXX compiler identification is MSVC 19.29.30154.0
-- The CUDA compiler identification is NVIDIA 12.1.66
-- Detecting CXX compiler ABI info
-- Detecting CXX compiler ABI info - done
-- Check for working CXX compiler: C:/Program Files (x86)/Microsoft Visual Studio/2019/Community/VC/Tools/MSVC/14.29.30133/bin/Hostx64/x64/cl.exe - skipped
-- Detecting CXX compile features
-- Detecting CXX compile features - done
-- Detecting CUDA compiler ABI info
-- Detecting CUDA compiler ABI info - done
-- Check for working CUDA compiler: C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v12.1/bin/nvcc.exe - skipped
-- Detecting CUDA compile features
-- Detecting CUDA compile features - done
-- Performing Test CMAKE_HAVE_LIBC_PTHREAD
-- Performing Test CMAKE_HAVE_LIBC_PTHREAD - Failed
-- Looking for pthread_create in pthreads
-- Looking for pthread_create in pthreads - not found
-- Looking for pthread_create in pthread
-- Looking for pthread_create in pthread - not found
-- Found Threads: TRUE
-- Performing Test HAVE_STDATOMIC
-- Performing Test HAVE_STDATOMIC - Success
-- Found WrapAtomic: TRUE
-- Found WrapVulkanHeaders: C:/VulkanSDK/1.3.290.0/Include
-- Found OpenCV: C:/opencv/build (found version "4.10.0") found components: core imgproc highgui dnn
-- Found CUDAToolkit: C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v12.1/include (found version "12.1.66")
-- Found Protobuf: C:/protobuf/build/Release/libprotobuf.lib (found version "5.26.1")
-- Found GSL: C:/vcpkg/packages;C:/Qt/6.7.1/msvc2019_64;C:/opencv/build;C:/onnxruntime/gsl_x64-windows/include (found version "")
-- Found CUDA: C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v12.1 (found version "12.1")
-- Found CUDAToolkit: C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v12.1/include (found version "12.1.66")
-- Caffe2: CUDA detected: 12.1
-- Caffe2: CUDA nvcc is: C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v12.1/bin/nvcc.exe
-- Caffe2: CUDA toolkit directory: C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v12.1
-- Caffe2: Header version is: 12.1
-- C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v12.1/lib/x64/nvrtc.lib shorthash is bac8224f
-- USE_CUDNN is set to 0. Compiling without cuDNN support
-- USE_CUSPARSELT is set to 0. Compiling without cuSPARSELt support
-- Autodetected CUDA architecture(s):  8.9
-- Added CUDA NVCC flags for: -gencode;arch=compute_89,code=sm_89
-- Found Torch: C:/libtorch/lib/torch.lib
-- Found Vulkan: C:/VulkanSDK/1.3.290.0/Lib (found version "1.3.292") found components: glslc glslangValidator
-- Vulkan INCLUDE found: C:/VulkanSDK/1.3.290.0/Include
-- Vulkan LIBRARY found: C:/VulkanSDK/1.3.290.0/Lib
-- glslc found: C:/VulkanSDK/1.3.290.0/Bin/glslc.exe
-- glslangValidator found: C:/VulkanSDK/1.3.290.0/Bin/glslangValidator.exe
-- CUDA Architectures set to: 89
-- USE_CUSPARSELT: ON
-- USE_CUDNN: ON
-- CAFFE2_USE_CUDNN: ON
-- cuDNN is enabled for Caffe2.
-- Found OpenMP_CXX: -openmp (found version "2.0")
-- Found OpenMP: TRUE (found version "2.0")
-- Configuring done (33.2s)
-- Generating done (0.2s)
-- Build files have been written to: C:/myLab/Project1/Project1/build











[vcpkg 설치 및 업그레이드]
Git을 사용하여 vcpkg를 클론
C:\>git clone https://github.com/microsoft/vcpkg.git
vcpkg 부트스트랩
C:\>cd vcpkg
C:\vcpkg>.\bootstrap-vcpkg.bat

[Protocol Buffers (protobuf)] Google에서 개발한 데이터 직렬화(serialization) 포맷
C:\vcpkg>.\vcpkg.exe install protobuf
"C:\vcpkg\packages\protobuf_x64-windows"
find_package(protobuf CONFIG REQUIRED)
target_link_libraries(main PRIVATE protobuf::libprotoc protobuf::libprotobuf protobuf::libprotobuf-lite)

[GSL(Gnu Scientific Library)] 과학적 계산과 수학적 작업을 지원하는 오픈 소스 라이브러리
C:\vcpkg>.\vcpkg.exe install gsl
"C:\vcpkg\packages\gsl_x64-windows"
find_package(GSL REQUIRED)
target_link_libraries(main PRIVATE GSL::gsl GSL::gslcblas)

[flatbuffers] Google에서 개발한 직렬화 라이브러리
C:\>git clone https://github.com/google/flatbuffers.git
C:\>cd flatbuffers
C:\flatbuffers>mkdir build
C:\flatbuffers>cd build
C:\flatbuffers\build>cmake -G "Visual Studio 16 2019" ..
-- Configuring done (6.9s)
-- Generating done (0.1s)
-- Build files have been written to: C:/flatbuffers/build
C:\flatbuffers\build>cmake --build .

1) CMakeLists.txt
cmake_minimum_required(VERSION 3.14)
project(Project1 LANGUAGES CXX CUDA)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

set(CMAKE_TOOLCHAIN_FILE "C:/vcpkg/scripts/buildsystems/vcpkg.cmake" CACHE FILEPATH "Path to vcpkg toolchain file")
set(CMAKE_PREFIX_PATH "C:/vcpkg/packages" "C:/Qt/6.7.1/msvc2019_64" "C:/opencv/build")

find_package(Qt6 REQUIRED COMPONENTS Widgets Core Gui)
find_package(OpenCV REQUIRED COMPONENTS core imgproc highgui cudaarithm cudafilters cudawarping cudacodec cudafeatures2d cudaimgproc dnn)
find_package(CUDA REQUIRED)

# ONNX 설정
# C:\>protoc --proto_path=C:\onnx\onnx --cpp_out=C:\onnx\onnx C:\onnx\onnx\onnx.proto
set(ONNX_ROOT "C:/onnx")
set(ONNX_DIR "C:/onnx/build") # ONNXConfig.cmake
include_directories("${ONNX_ROOT}")
link_directories("${ONNX_ROOT}/build/lib/pkgconfig")
# Protobuf 설정
set(Protobuf_ROOT "${CMAKE_PREFIX_PATH}/protobuf_x64-windows")
set(Protobuf_INCLUDE_DIR "${Protobuf_ROOT}/include/google/protobuf")
set(Protobuf_LIB "${Protobuf_ROOT}/bin")
include_directories(${Protobuf_INCLUDE_DIR})
link_directories("${Protobuf_LIB}")
#onnx.pb.h생성(실패)
#find_package(Protobuf REQUIRED)
# Protobuf 설치 경로 설정 (경로는 실제 Protobuf 설치 경로로 수정해야 합니다)
# set(CMAKE_PREFIX_PATH "C:/vcpkg/packages/protobuf_x64-windows" ${CMAKE_PREFIX_PATH})
# Set Protobuf include directories
#include_directories(${PROTOBUF_INCLUDE_DIRS})
# Protobuf files
#set(PROTO_FILES
#    ${CMAKE_CURRENT_SOURCE_DIR}/onnx/onnx.proto
#)
# Generate Protobuf C++ files
#protobuf_generate_cpp(PROTO_SRCS PROTO_HDRS ${PROTO_FILES})
# Create library from generated files
#add_library(onnx_proto ${PROTO_SRCS} ${PROTO_HDRS})
# Link against Protobuf
#target_link_libraries(onnx_proto ${PROTOBUF_LIBRARIES})

# GSL 설정 추가
set(GSL_ROOT "${CMAKE_PREFIX_PATH}/gsl_x64-windows")
set(GSL_INCLUDE_DIR "${GSL_ROOT}/include")
set(GSL_LIBRARY "${GSL_ROOT}/lib")
set(GSL_CBLAS_LIBRARY "${GSL_LIBRARY}/gslcblas.lib")
include_directories(${GSL_INCLUDE_DIR})
link_directories("${GSL_LIBRARY}" "${GSL_CBLAS_LIBRARY}")

# LibTorch 설정
set(TORCH_ROOT "C:/libtorch")
set(Torch_DIR "${TORCH_ROOT}/share/cmake/Torch")
include_directories("${TORCH_ROOT}/include")
link_directories("${TORCH_ROOT}/lib")
find_package(Torch REQUIRED)

# ONNX Runtime 설정
set(ONNX_RUNTIME_ROOT "C:/onnxruntime")
include_directories( 
    "${ONNX_RUNTIME_ROOT}"
    "${ONNX_RUNTIME_ROOT}/cmake/build/_deps/safeint-src"
    "${ONNX_RUNTIME_ROOT}/cmake/build/_deps/mp11-src/include"
    "${ONNX_RUNTIME_ROOT}/cmake/build/_deps/onnx-src/onnx"
    "${ONNX_RUNTIME_ROOT}/cmake/build"
    "${ONNX_RUNTIME_ROOT}/build"
    "${ONNX_RUNTIME_ROOT}/onnxruntime"
    "${ONNX_RUNTIME_ROOT}/build/_deps/mp11-src/include"
    "${ONNX_RUNTIME_ROOT}/build/_deps/safeint-src"
    "${ONNX_RUNTIME_ROOT}/include/onnxruntime"
    "${ONNX_RUNTIME_ROOT}/include/onnxruntime/core/session"
    )
link_directories("${ONNX_RUNTIME_ROOT}/cmake/build/Debug")
find_library(ONNXRUNTIME_LIB NAMES custom_op_local_function PATHS "${ONNX_RUNTIME_ROOT}/cmake/build/Debug")
if (ONNXRUNTIME_LIB)
    message(STATUS "Found ONNX Runtime library: ${ONNXRUNTIME_LIB}")
else()
    message(FATAL_ERROR "ONNX Runtime library not found")
endif()
set(ONNX_RUNTIME_LIB_DIR "${ONNX_RUNTIME_ROOT}/build/${CMAKE_BUILD_TYPE}")

# IPP 설정
set(IPP_ROOT "C:/Program Files (x86)/Intel/oneAPI/ipp/2021.11")
include_directories("${IPP_ROOT}/include")
link_directories("${IPP_ROOT}/lib")

# GStreamer 설정
set(GSTREAMER_ROOT "C:/gstreamer/1.0/msvc_x86_64")
include_directories(
    "${GSTREAMER_ROOT}/include/gstreamer-1.0"
    "${GSTREAMER_ROOT}/include/glib-2.0"
    "${GSTREAMER_ROOT}/lib/glib-2.0/include"
)
link_directories("${GSTREAMER_ROOT}/lib")

# IPLIB 설정
set(IPLIB_ROOT "C:/myLab/Project1/Project1/imageProcessingLib")
include_directories("${IPLIB_ROOT}")
link_directories(
    "${IPLIB_ROOT}/build/lib/${CMAKE_BUILD_TYPE}"
    "${IPLIB_ROOT}/build/bin/${CMAKE_BUILD_TYPE}"
    "${IPLIB_ROOT}/build/${CMAKE_BUILD_TYPE}"
)

# Abseil 라이브러리 설정
# Google이 개발하고 관리하는 오픈 소스 C++ 라이브러리
set(ABSEIL_ROOT "C:/abseil-cpp")
include_directories("${ABSEIL_ROOT}")
link_directories("${ABSEIL_ROOT}/build/lib")

# flatbuffers 설정
set(FLATBUFFERS_ROOT "C:/flatbuffers")
include_directories("${FLATBUFFERS_ROOT}/include")
link_directories("${FLATBUFFERS_ROOT}/build/Debug")

# date 설정
set(DATE_ROOT "C:/date")
include_directories("${DATE_ROOT}/include")
link_directories("${DATE_ROOT}/build/Debug")

# CUDA 아키텍처 설정
set(CUDA_ARCHITECTURES "86")
message(STATUS "CUDA Architectures set to: ${CUDA_ARCHITECTURES}")

# CUDA 파일 설정
set(CUDA_NVCC_FLAGS ${CUDA_NVCC_FLAGS} -std=c++14 --expt-relaxed-constexpr -gencode arch=compute_86,code=sm_86)

# CUDA 파일 컴파일 및 라이브러리 생성
cuda_add_library(image_processing
    imageProcessing.cu
)

# Qt 래핑 파일 생성
qt6_wrap_cpp(MOC_FILES
    MainWindow.h
    ImageProcessor.h
    DetectDialog.h
)

# 라이브러리 링크
target_link_libraries(image_processing
    ippcc.lib
    ippcore.lib
    ippvm.lib
    ipps.lib
    ippi.lib
    ippcv.lib
    nppial
    nppicc
    nppidei
    nppif
    nppig
    nppim
    nppist
    nppisu
    nppitc
    npps
    imageProcessingLib
    flatbuffers
    date
    gstreamer-1.0.lib
    gobject-2.0.lib
    glib-2.0.lib
    gstapp-1.0.lib
    gstbase-1.0.lib
    gstvideo-1.0.lib
)

# 실행 파일 추가
add_executable(Project1
    main.cpp
    MainWindow.cpp
    MainWindow.h
    MainWindow.ui
    ImageProcessor.cpp
    ImageProcessor.h
    ${MOC_FILES}
)

# 라이브러리 링크
target_link_libraries(Project1
    Qt6::Widgets
    Qt6::Core
    Qt6::Gui
    ${OpenCV_LIBS}
    image_processing
    imageProcessingLib
    ${CUDA_LIBRARIES}
    ${CUDNN_LIBRARIES}
    ${GSTREAMER_LIBRARIES}
    ${TORCH_LIBRARIES}  # LibTorch 링크
    flatbuffers
    date
    ${ONNX_RUNTIME_LIB}
    ${ONNX_LIB}
    ${Protobuf_LIB}
    ${ONNX_DIR}/onnx/onnx-operators.pb.cc
)

# 빌드 후 TARGET_FILE_DIR 출력
add_custom_command(TARGET Project1 POST_BUILD
    COMMAND ${CMAKE_COMMAND} -E echo "TARGET_FILE_DIR for Project1: $<TARGET_FILE_DIR:Project1>"
    COMMAND ${CMAKE_COMMAND} -E echo "$<TARGET_FILE_DIR:Project1>" > "Project1_dir.txt"
)

# 실행 파일 출력 디렉토리 설정
set_target_properties(Project1 PROPERTIES
    RUNTIME_OUTPUT_DIRECTORY_DEBUG "${CMAKE_BINARY_DIR}/Debug"
    RUNTIME_OUTPUT_DIRECTORY_RELEASE "${CMAKE_BINARY_DIR}/Release"
)

file(COPY "C:/myLab/Project1/Project1/imageProcessingLib/build/Debug/imageProcessingLib.dll"
     DESTINATION "${CMAKE_BINARY_DIR}/Debug"
)

# 디버그 빌드에서의 OpenCV opencv_world DLL 복사
add_custom_command(TARGET Project1 POST_BUILD
    COMMAND ${CMAKE_COMMAND} -E copy_if_different
    "C:/opencv/build/x64/vc16/bin/opencv_world4100d.dll" "$<TARGET_FILE_DIR:Project1>"
    COMMENT "Copying OpenCV Debug opencv_world DLL to output directory"
)

# 릴리스 빌드에서의 OpenCV opencv_world DLL 복사
add_custom_command(TARGET Project1 POST_BUILD
    COMMAND ${CMAKE_COMMAND} -E copy_if_different
    "C:/opencv/build/x64/vc16/bin/opencv_world4100.dll" "$<TARGET_FILE_DIR:Project1>"
    COMMENT "Copying OpenCV Release opencv_world DLL to output directory"
)

# 디버그 빌드에서의 OpenCV DLL 복사
add_custom_command(TARGET Project1 POST_BUILD
    COMMAND ${CMAKE_COMMAND} -E copy_if_different
    "C:/opencv/build/bin/Debug/opencv_dnn4100d.dll" "$<TARGET_FILE_DIR:Project1>"
    COMMAND ${CMAKE_COMMAND} -E copy_if_different
    "C:/opencv/build/bin/Debug/opencv_cudaarithm4100d.dll" "$<TARGET_FILE_DIR:Project1>"
    COMMAND ${CMAKE_COMMAND} -E copy_if_different
    "C:/opencv/build/bin/Debug/opencv_cudaimgproc4100d.dll" "$<TARGET_FILE_DIR:Project1>"
    COMMAND ${CMAKE_COMMAND} -E copy_if_different
    "C:/opencv/build/bin/Debug/opencv_cudafilters4100d.dll" "$<TARGET_FILE_DIR:Project1>"
    COMMAND ${CMAKE_COMMAND} -E copy_if_different
    "C:/opencv/build/bin/Debug/opencv_imgcodecs4100d.dll" "$<TARGET_FILE_DIR:Project1>"
    COMMAND ${CMAKE_COMMAND} -E copy_if_different
    "C:/opencv/build/bin/Debug/opencv_core4100d.dll" "$<TARGET_FILE_DIR:Project1>"
    COMMAND ${CMAKE_COMMAND} -E copy_if_different
    "C:/opencv/build/bin/Debug/opencv_imgproc4100d.dll" "$<TARGET_FILE_DIR:Project1>"
    COMMENT "Copying OpenCV Debug DLLs to output directory"
)

# 릴리스 빌드에서의 OpenCV DLL 복사
add_custom_command(TARGET Project1 POST_BUILD
    COMMAND ${CMAKE_COMMAND} -E copy_if_different
    "C:/opencv/build/bin/Release/opencv_dnn4100.dll" "$<TARGET_FILE_DIR:Project1>"
    COMMAND ${CMAKE_COMMAND} -E copy_if_different
    "C:/opencv/build/bin/Release/opencv_cudaarithm4100.dll" "$<TARGET_FILE_DIR:Project1>"
    COMMAND ${CMAKE_COMMAND} -E copy_if_different
    "C:/opencv/build/bin/Release/opencv_cudaimgproc4100.dll" "$<TARGET_FILE_DIR:Project1>"
    COMMAND ${CMAKE_COMMAND} -E copy_if_different
    "C:/opencv/build/bin/Release/opencv_cudafilters4100.dll" "$<TARGET_FILE_DIR:Project1>"
    COMMAND ${CMAKE_COMMAND} -E copy_if_different
    "C:/opencv/build/bin/Release/opencv_imgcodecs4100.dll" "$<TARGET_FILE_DIR:Project1>"
    COMMAND ${CMAKE_COMMAND} -E copy_if_different
    "C:/opencv/build/bin/Release/opencv_core4100.dll" "$<TARGET_FILE_DIR:Project1>"
    COMMAND ${CMAKE_COMMAND} -E copy_if_different
    "C:/opencv/build/bin/Release/opencv_imgproc4100.dll" "$<TARGET_FILE_DIR:Project1>"
    COMMENT "Copying OpenCV Release DLLs to output directory"
)

# 파일 인코딩 설정 추가
add_compile_options("$<$<CXX_COMPILER_ID:MSVC>:/utf-8>")

# OpenMP 설정
find_package(OpenMP REQUIRED)
if(OpenMP_CXX_FOUND)
    target_link_libraries(Project1 OpenMP::OpenMP_CXX)
endif()

if (MSVC)
    set_property(DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR} PROPERTY VS_STARTUP_PROJECT Project1)

    # Debug 빌드
    set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} /MDd")
    set(CMAKE_C_FLAGS_DEBUG "${CMAKE_C_FLAGS_DEBUG} /MDd")

    # Release 빌드
    set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} /MD")
    set(CMAKE_C_FLAGS_RELEASE "${CMAKE_C_FLAGS_RELEASE} /MD")

    # 반복자 디버그 레벨 설정
    add_compile_definitions(
        $<$<CONFIG:Debug>:_ITERATOR_DEBUG_LEVEL=2>
        $<$<CONFIG:Release>:_ITERATOR_DEBUG_LEVEL=0>
    )
endif()


2) yolov5로 학습된 best.pt를 best.onnx파일로 export (python 3.12.3 myenv c:/myenv가상환경)
# C:/yolov5/runs/train/exp30/weights/best.pt (인식률이나오는걸로고름)
# C:\myLab\Project1\Project1\python\myTorchScript.py
import sys
import torch
import onnx
import onnxruntime as ort
import os

# 디버깅 정보 저장 리스트
debug_info = []

def log_debug_info(message):
    debug_info.append(message)

# YOLOv5 경로를 추가합니다
sys.path.append('C:/yolov5')
log_debug_info("YOLOv5 path added to system path.")

# 모델 경로 설정
model_path = 'C:/yolov5/runs/train/exp30/weights/best.pt'
log_debug_info(f"Model path set to: {model_path}")

# CUDA가 사용 가능한 경우, CUDA로 로드하고, 그렇지 않으면 CPU로 로드합니다
device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
log_debug_info(f"Using device: {device}")

# 모델 로드
try:
    log_debug_info("Attempting to load the model...")
    model = torch.load(model_path, map_location=device, weights_only=False)['model'].float()
    model.to(device)
    model.eval()
    log_debug_info("Model loaded and set to evaluation mode.")
except Exception as e:
    log_debug_info(f"Error loading model: {str(e)}")
    sys.exit()

# 더미 입력 텐서 생성 (CUDA 또는 CPU에 맞게 설정)
dummy_input = torch.randn(1, 3, 640, 640).to(device)
log_debug_info(f"Dummy input tensor created with shape: {dummy_input.shape}")

# ONNX로 모델 내보내기
onnx_path = 'C:/myLab/Project1/Project1/python/best.onnx'
log_debug_info(f"Export path set to: {onnx_path}")

try:
    log_debug_info("Attempting to export model to ONNX format...")
    torch.onnx.export(
        model,
        dummy_input,
        onnx_path,
        verbose=True,
        opset_version=12,
        input_names=['input'],
        output_names=['output'],
        dynamic_axes={
            'input': {0: 'batch_size'},
            'output': {0: 'batch_size'}
        }
    )
    if os.path.exists(onnx_path):
        log_debug_info(f"ONNX file successfully created at: {onnx_path}")
    else:
        log_debug_info(f"Failed to create ONNX file at: {onnx_path}")
except Exception as e:
    log_debug_info(f"Error exporting model to ONNX: {str(e)}")
    sys.exit()

# ONNX Runtime 버전과 CUDA 버전 출력
try:
    log_debug_info(f"ONNX Runtime version: {ort.__version__}")
except Exception as e:
    log_debug_info(f"Error getting ONNX Runtime version: {str(e)}")

try:
    log_debug_info(f"CUDA version: {torch.version.cuda}")
except Exception as e:
    log_debug_info(f"Error getting CUDA version: {str(e)}")

# ONNX 모델 검증
try:
    log_debug_info("Attempting to validate the ONNX model...")
    onnx_model = onnx.load(onnx_path)
    onnx.checker.check_model(onnx_model)
    log_debug_info("ONNX model is valid.")
except Exception as e:
    log_debug_info(f"Error validating ONNX model: {str(e)}")
    sys.exit()

# ONNX Runtime 세션 생성 (GPU 사용)
try:
    log_debug_info("Creating ONNX Runtime session...")
    providers = ['CUDAExecutionProvider'] if torch.cuda.is_available() else ['CPUExecutionProvider']
    ort_session = ort.InferenceSession(onnx_path, providers=providers)
    log_debug_info(f"ONNX Runtime session created with {'GPU' if torch.cuda.is_available() else 'CPU'} support.")
except Exception as e:
    log_debug_info(f"Error creating ONNX Runtime session: {str(e)}")
    sys.exit()

# 더미 입력 준비
dummy_input_np = dummy_input.cpu().numpy()
log_debug_info(f"Dummy input numpy array created with shape: {dummy_input_np.shape}")

# 추론 실행
try:
    log_debug_info("Running inference...")
    outputs = ort_session.run(None, {'input': dummy_input_np})
    log_debug_info("Inference completed. Outputs:")
    log_debug_info(str(outputs))
except Exception as e:
    log_debug_info(f"Error running inference: {str(e)}")

# 모든 디버깅 정보를 출력
print("\n--- Debug Information ---")
for info in debug_info:
    print(info)

2) C:\ObjectDetect\onnxDetectImage.py 파일만들어서 객체감지 테스트 (Python 3.12.3 c:/pythonEnv 가상환경)
#C:\ObjectDetect\onnxDetectImage.py
#76% 인식률 나옴
import cv2
import numpy as np
import onnxruntime as ort

# ONNX 모델 경로와 이미지 경로
model_path = "C:/myLab/Project1/Project1/python/best.onnx"
image_path = "C:/ObjectDetect/cups.jpg"

# 모델 불러오기
session = ort.InferenceSession(model_path)

# 클래스 이름 (모델 학습 시 사용된 클래스 목록을 여기에 정의)
class_names = ["cup"]

# 이미지 불러오기
image = cv2.imread(image_path)
orig_img = image.copy()
h, w = image.shape[:2]

# 이미지 전처리
input_size = 640  # YOLOv5 기본 입력 사이즈
image = cv2.resize(image, (input_size, input_size))
image = image.transpose(2, 0, 1)  # HWC to CHW
image = np.expand_dims(image, axis=0)
image = image.astype(np.float32) / 255.0

# ONNX 모델 추론
input_name = session.get_inputs()[0].name
outputs = session.run(None, {input_name: image})

# YOLOv5는 여러 스케일에서 감지된 결과를 반환합니다.
predictions = outputs[0]

# 후처리: NMS (Non-Maximum Suppression)
def nms(boxes, scores, iou_threshold):
    indices = cv2.dnn.NMSBoxes(boxes, scores, score_threshold=0.5, nms_threshold=iou_threshold)
    return indices

def process_predictions(predictions, h, w):
    boxes = []
    confidences = []
    class_ids = []

    for pred in predictions:
        # 박스 좌표 (x_center, y_center, width, height)
        pred = pred.reshape(-1, 6)  # reshape to (num_boxes, 6) if necessary

        for box in pred:
            # 박스 좌표와 confidence 값 추출
            x_center, y_center, width, height, score = box[:5]
            class_scores = box[5:]

            # confidence 및 class_id 추출
            class_id = np.argmax(class_scores)
            score = float(score)

            if score >= 0.5:  # confidence threshold
                # 좌표를 원본 이미지 크기로 변환
                x = int((x_center - width / 2) * w / input_size)
                y = int((y_center - height / 2) * h / input_size)
                width = int(width * w / input_size)
                height = int(height * h / input_size)

                boxes.append([x, y, width, height])
                confidences.append(score)
                class_ids.append(class_id)

    # NMS 적용
    indices = nms(boxes, confidences, 0.4)

    # indices가 비어 있지 않은지 확인
    if len(indices) > 0:
        indices = indices.flatten()  # 2D 배열을 1D 배열로 변환
        results = [(class_ids[i], boxes[i], confidences[i]) for i in indices]
    else:
        results = []  # 감지된 객체가 없는 경우 빈 리스트 반환
    
    return results

# 결과 처리
results = process_predictions(predictions, h, w)

# 결과 표시
for class_id, box, confidence in results:
    if class_id < len(class_names):  # class_id가 class_names의 범위 내에 있는지 확인
        x, y, width, height = box
        label = f"{class_names[class_id]}: {confidence:.2f}"
        cv2.rectangle(orig_img, (x, y), (x + width, y + height), (0, 255, 0), 2)
        cv2.putText(orig_img, label, (x, y - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 0), 2)
    else:
        print(f"Invalid class_id {class_id}. It exceeds the number of class names.")

# 이미지 출력
cv2.imshow("Detected Objects", orig_img)
cv2.waitKey(0)
cv2.destroyAllWindows()
