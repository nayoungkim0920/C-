1. 가상환경생성
cd C:\myLab\Project1\Project1\python
python -m venv myenv
C:\myLab\Project1\Project1\python\myenv\Scripts\activate

2.torch설치(Gpu)
(cpu) pip install torch torchvision torchaudio
print(torch.__version__)
2.4.0+cpu

(pc)
nvcc --version
nvcc: NVIDIA (R) Cuda compiler driver
Copyright (c) 2005-2023 NVIDIA Corporation
Built on Wed_Feb__8_05:53:42_Coordinated_Universal_Time_2023
Cuda compilation tools, release 12.1, V12.1.66
Build cuda_12.1.r12.1/compiler.32415258_0

(gpu)
pip install torch==2.0.0+cu121 torchvision==0.15.1+cu121 torchaudio==2.0.0+cu121 -f https://download.pytorch.org/whl/torch_stable.html
->12.1과 호환되지않아 11.8로 설치
pip install torch==2.0.0+cu118 torchvision==0.15.1+cu118 torchaudio==2.0.0+cu118 -f https://download.pytorch.org/whl/torch_stable.html

(버전확인)
(base) (myenv) C:\myLab\Project1\Project1\python>python
Python 3.11.8 | packaged by Anaconda, Inc. | (main, Feb 26 2024, 21:34:05) [MSC v.1916 64 bit (AMD64)] on win32
Type "help", "copyright", "credits" or "license" for more information.
>>> import torch
>>> print("PyTorch version:", torch.__version__)
PyTorch version: 2.0.0+cu118
>>> print("CUDA available:", torch.cuda.is_available())
CUDA available: True
>>> print("CUDA version:", torch.version.cuda)
CUDA version: 11.8

3. opencv-python 설치
pip install opencv-python

4. pandas 설치
pip install pandas

5. requests 설치
pip install requests

6. onnx설치
pip install onnx
pip install --upgrade onnx protobuf numpy onnxruntime
pip install onnxruntime
python.exe -m pip install --upgrade pip
conda install -c conda-forge onnx
python myTorchScript.py
python
import onnx
print(onnx.__version__)
1.16.2

7. onnx파일 생성 및 검증
- 생성 : "C:\myLab\Project1\Project1\python\yolov5m.onnx"
(base) (myenv) C:\myLab\Project1\Project1\python>python myTorchScript.py
Model has been exported to ONNX format at C:/myLab/Project1/Project1/python/yolov5m.onnx

# myTorchScript.py
import sys
import torch

# YOLOv5 경로를 추가합니다
sys.path.append('C:/yolov5')

# 모델 로드 (CUDA로)
model_path = 'C:/yolov5/yolov5m.pt'

# CUDA가 사용 가능한 경우, CUDA로 로드하고, 그렇지 않으면 CPU로 로드합니다
device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
model = torch.load(model_path, map_location=device)['model'].float()
model.to(device)  # 모델을 CUDA로 이동
model.eval()

# 더미 입력 텐서 생성 (CUDA 또는 CPU에 맞게 설정)
dummy_input = torch.randn(1, 3, 640, 640).to(device)  # YOLOv5의 기본 입력 크기

# ONNX로 모델 내보내기
onnx_path = 'C:/myLab/Project1/Project1/python/yolov5m.onnx'
torch.onnx.export(
    model,
    dummy_input,
    onnx_path,
    verbose=True,
    opset_version=12,  # ONNX Opset version 변경
    input_names=['input'],
    output_names=['output']
)

print("Model has been exported to ONNX format at", onnx_path)

- 검증
# myTorchScriptCheck.py
import torch
import numpy as np

# PyTorch 모델 로드 (CUDA에서)
device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
model_path = 'C:/yolov5/yolov5m.pt'
model = torch.load(model_path, map_location=device)['model'].float().to(device)
model.eval()

# 더미 입력 텐서 생성 (CUDA 또는 CPU에 맞게 설정)
dummy_input = torch.randn(1, 3, 640, 640).to(device)

# PyTorch 모델로 추론
with torch.no_grad():
    torch_outputs = model(dummy_input)

print("PyTorch model inference completed.")
print("PyTorch model output shape:", torch_outputs.shape)

# PyTorch 결과를 NumPy 배열로 변환
torch_outputs_np = torch_outputs.cpu().numpy()

# 출력 결과 비교
print("Comparing PyTorch and ONNX model outputs...")

# ONNX와 PyTorch 출력 차이 계산
for i, (torch_out, onnx_out) in enumerate(zip(torch_outputs_np, onnx_outputs)):
    diff = np.abs(torch_out - onnx_out).max()
    print(f"Output {i} max difference: {diff}")

    if diff > 1e-5:  # 허용 오차를 설정
        print(f"Warning: Output {i} difference exceeds threshold.")
    else:
        print(f"Output {i} comparison passed.")

(출력) ONNX 모델의 추론이 성공적으로 완료
(base) (myenv) C:\myLab\Project1\Project1\python>python myTorchScriptCheck.py
ONNX model inference completed.
ONNX model output shape: [(1, 25200, 85), (1, 3, 80, 80, 85), (1, 3, 40, 40, 85), (1, 3, 20, 20, 85)]

8. ONNX Runtime C++ 라이브러리 설치
(base) (myenv) C:\myLab\Project1\Project1\python>git clone --recursive https://github.com/microsoft/onnxruntime.git

9. myenv, onnxruntime c:/로 위치 이동
- onnxruntime설치
git clone --recursive https://github.com/microsoft/onnxruntime.git
or
git clone --recursive https://github.com/microsoft/onnxruntime.git C:\onnxruntime
or
onnxruntime-main.zip(https://github.com/microsoft/onnxruntime)
- Cmake
cd C:\onnxruntime\build Release
cmake ..\cmake -DCMAKE_BUILD_TYPE=Release -DONNX_RUNTIME_BUILD_SHARED_LIBS=ON
cmake --build . --config Release
-> C:\onnxruntime\build\Release 생성

cmake ..\cmake -DCMAKE_BUILD_TYPE=Debug -DONNX_RUNTIME_BUILD_SHARED_LIBS=ON
cmake --build . --config Debug
-> C:\onnxruntime\build\Debug 생성

10. CmakeLists.txt 수정
cmake_minimum_required(VERSION 3.14)
project(Project1 LANGUAGES CXX CUDA)

# Qt, OpenCV, CUDA 설정
set(CMAKE_PREFIX_PATH "C:/Qt/6.7.1/msvc2019_64" "C:/opencv/build")
find_package(Qt6 REQUIRED COMPONENTS Widgets Core Gui)
find_package(OpenCV REQUIRED COMPONENTS core imgproc highgui cudaarithm cudafilters cudawarping cudacodec cudafeatures2d cudaimgproc)
find_package(CUDA REQUIRED)

# LibTorch 설정
set(TORCH_ROOT "C:/libtorch")
#if(CMAKE_BUILD_TYPE STREQUAL "Debug")
#    set(TORCH_ROOT "C:/myLab/libtorch_Debug")
#else()
#    set(TORCH_ROOT "C:/myLab/libtorch_Release")
#endif()
set(CMAKE_PREFIX_PATH "${CMAKE_PREFIX_PATH};${TORCH_ROOT}")
find_package(Torch REQUIRED)

# IPP 설정
set(IPP_ROOT "C:/Program Files (x86)/Intel/oneAPI/ipp/2021.11")
include_directories("${IPP_ROOT}/include")
link_directories("${IPP_ROOT}/lib")

# GStreamer 설정
set(GSTREAMER_ROOT "C:/gstreamer/1.0/msvc_x86_64")
include_directories(
    "${GSTREAMER_ROOT}/include/gstreamer-1.0"
    "${GSTREAMER_ROOT}/include/glib-2.0"
    "${GSTREAMER_ROOT}/lib/glib-2.0/include"
)
link_directories("${GSTREAMER_ROOT}/lib")

# IPP 설정
set(IPLIB_ROOT "C:/myLab/Project1/Project1/imageProcessingLib")
include_directories("${IPLIB_ROOT}")
link_directories(
    "${IPLIB_ROOT}/build/lib/Debug"
    "${IPLIB_ROOT}/build/bin/Debug"
    "${IPLIB_ROOT}/build/Debug"
    )

# ONNX Runtime 설정
set(ONNX_RUNTIME_INCLUDE_DIR "C:/onnxruntime/include/onnxruntime/core")
if(CMAKE_BUILD_TYPE STREQUAL "Debug")
    set(ONNX_RUNTIME_LIB_DIR "C:/onnxruntime/build/Debug")
else()
    set(ONNX_RUNTIME_LIB_DIR "C:/onnxruntime/build/Release")
endif()

include_directories(${ONNX_RUNTIME_INCLUDE_DIR})
link_directories(${ONNX_RUNTIME_LIB_DIR})

# 추가 포함 디렉터리 설정
include_directories(
    ${CUDA_INCLUDE_DIRS}
    ${OpenCV_INCLUDE_DIRS}
    "${CUDA_TOOLKIT_ROOT_DIR}/include"
    ${IPP_ROOT}/include
    "${GSTREAMER_ROOT}/include/gstreamer-1.0"
    "${GSTREAMER_ROOT}/lib/gstreamer-1.0/include"
    ${TORCH_ROOT}/include  # LibTorch 포함 디렉토리
    ${ONNXRuntime_INCLUDE_DIRS}  # ONNX Runtime 포함 디렉토리
)

# CUDA 파일 설정
set(CUDA_NVCC_FLAGS ${CUDA_NVCC_FLAGS} -std=c++14 --expt-relaxed-constexpr -gencode arch=compute_86,code=sm_86)

# Qt 래핑 파일 생성
qt6_wrap_cpp(MOC_FILES
    MainWindow.h
    ImageProcessor.h
    yolov5dialog.h
)

# CUDA 파일 컴파일 및 라이브러리 생성
cuda_add_library(image_processing
    imageProcessing.cu
)

# 라이브러리 디렉토리 설정
link_directories("${CMAKE_BINARY_DIR}")  # 라이브러리 디렉토리 설정

# 라이브러리 링크
target_link_libraries(image_processing
    ippcc.lib
    ippcore.lib
    ippvm.lib
    ipps.lib
    ippi.lib
    ippcv.lib
    nppial
    nppicc
    nppidei
    nppif
    nppig
    nppim
    nppist
    nppisu
    nppitc
    npps
    imageProcessingLib
)

# GStreamer 라이브러리 추가
list(APPEND GSTREAMER_LIBRARIES
    gstreamer-1.0.lib
    gobject-2.0.lib
    glib-2.0.lib
    gstapp-1.0.lib
    gstbase-1.0.lib
    gstvideo-1.0.lib
)

# 실행 파일 추가
add_executable(Project1
    main.cpp
    MainWindow.cpp
    MainWindow.h
    MainWindow.ui
    ImageProcessor.cpp
    ImageProcessor.h
    ${MOC_FILES}
)

# 라이브러리 링크
target_link_libraries(Project1
    Qt6::Widgets
    Qt6::Core
    Qt6::Gui
    ${OpenCV_LIBS}
    image_processing
    imageProcessingLib
    ${CUDA_LIBRARIES}
    ${CUDNN_LIBRARIES}
    ${GSTREAMER_LIBRARIES}
    ${TORCH_ROOT}/lib # LibTorch 링크
    ${ONNXRuntime_LIBRARIES}  # ONNX Runtime 링크
)

# 빌드 후 TARGET_FILE_DIR 출력
add_custom_command(TARGET Project1 POST_BUILD
    COMMAND ${CMAKE_COMMAND} -E echo "TARGET_FILE_DIR for Project1: $<TARGET_FILE_DIR:Project1>"
    COMMAND ${CMAKE_COMMAND} -E echo "$<TARGET_FILE_DIR:Project1>" > "Project1_dir.txt"
)

# 실행 파일 출력 디렉토리 설정
set_target_properties(Project1 PROPERTIES
    RUNTIME_OUTPUT_DIRECTORY_DEBUG "${CMAKE_BINARY_DIR}/Debug"
    RUNTIME_OUTPUT_DIRECTORY_RELEASE "${CMAKE_BINARY_DIR}/Release"
)

file(COPY "C:/myLab/Project1/Project1/imageProcessingLib/build/Debug/imageProcessingLib.dll"
     DESTINATION "${CMAKE_BINARY_DIR}/Debug"
)

#file(COPY "C:/myLab/Project1/Project1/imageProcessingLib/build/bin/Debug/imageProcessingLib.lib"
#     DESTINATION "${CMAKE_BINARY_DIR}/Debug"
#)

#file(COPY "C:/myLab/Project1/Project1/imageProcessingLib/build/bin/Debug/imageProcessingLib.lib"
#     DESTINATION "${CMAKE_BINARY_DIR}/Debug"
#)

# 디버그 빌드에서의 OpenCV opencv_world DLL 복사
add_custom_command(TARGET Project1 POST_BUILD
    COMMAND ${CMAKE_COMMAND} -E copy_if_different
    "C:/opencv/build/x64/vc16/bin/opencv_world4100d.dll" "$<TARGET_FILE_DIR:Project1>"
    COMMENT "Copying OpenCV Debug opencv_world DLL to output directory"
)

# 릴리스 빌드에서의 OpenCV opencv_world DLL 복사
add_custom_command(TARGET Project1 POST_BUILD
    COMMAND ${CMAKE_COMMAND} -E copy_if_different
    "C:/opencv/build/x64/vc16/bin/opencv_world4100.dll" "$<TARGET_FILE_DIR:Project1>"
    COMMENT "Copying OpenCV Release opencv_world DLL to output directory"
)

# 디버그 빌드에서의 OpenCV DLL 복사
add_custom_command(TARGET Project1 POST_BUILD
    COMMAND ${CMAKE_COMMAND} -E copy_if_different
    "C:/opencv/build/bin/Debug/opencv_cudaarithm4100d.dll" "$<TARGET_FILE_DIR:Project1>"
    COMMAND ${CMAKE_COMMAND} -E copy_if_different
    "C:/opencv/build/bin/Debug/opencv_cudaimgproc4100d.dll" "$<TARGET_FILE_DIR:Project1>"
    COMMAND ${CMAKE_COMMAND} -E copy_if_different
    "C:/opencv/build/bin/Debug/opencv_cudafilters4100d.dll" "$<TARGET_FILE_DIR:Project1>"
    COMMAND ${CMAKE_COMMAND} -E copy_if_different
    "C:/opencv/build/bin/Debug/opencv_imgcodecs4100d.dll" "$<TARGET_FILE_DIR:Project1>"
    COMMAND ${CMAKE_COMMAND} -E copy_if_different
    "C:/opencv/build/bin/Debug/opencv_core4100d.dll" "$<TARGET_FILE_DIR:Project1>"
    COMMAND ${CMAKE_COMMAND} -E copy_if_different
    "C:/opencv/build/bin/Debug/opencv_imgproc4100d.dll" "$<TARGET_FILE_DIR:Project1>"
    COMMENT "Copying OpenCV Debug DLLs to output directory"
)

# 릴리스 빌드에서의 OpenCV DLL 복사
add_custom_command(TARGET Project1 POST_BUILD
    COMMAND ${CMAKE_COMMAND} -E copy_if_different
    "C:/opencv/build/bin/Release/opencv_cudaarithm4100.dll" "$<TARGET_FILE_DIR:Project1>"
    COMMAND ${CMAKE_COMMAND} -E copy_if_different
    "C:/opencv/build/bin/Release/opencv_cudaimgproc4100.dll" "$<TARGET_FILE_DIR:Project1>"
    COMMAND ${CMAKE_COMMAND} -E copy_if_different
    "C:/opencv/build/bin/Release/opencv_cudafilters4100.dll" "$<TARGET_FILE_DIR:Project1>"
    COMMAND ${CMAKE_COMMAND} -E copy_if_different
    "C:/opencv/build/bin/Release/opencv_imgcodecs4100.dll" "$<TARGET_FILE_DIR:Project1>"
    COMMAND ${CMAKE_COMMAND} -E copy_if_different
    "C:/opencv/build/bin/Release/opencv_core4100.dll" "$<TARGET_FILE_DIR:Project1>"
    COMMAND ${CMAKE_COMMAND} -E copy_if_different
    "C:/opencv/build/bin/Release/opencv_imgproc4100.dll" "$<TARGET_FILE_DIR:Project1>"
    COMMENT "Copying OpenCV Release DLLs to output directory"
)

# 파일 인코딩 설정 추가
add_compile_options("$<$<CXX_COMPILER_ID:MSVC>:/utf-8>")

# OpenMP 설정
find_package(OpenMP REQUIRED)
if(OpenMP_CXX_FOUND)
    target_link_libraries(Project1 OpenMP::OpenMP_CXX)
endif()

if (MSVC)
    set_property(DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR} PROPERTY VS_STARTUP_PROJECT Project1)

    # Debug 빌드
    set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} /MDd")
    set(CMAKE_C_FLAGS_DEBUG "${CMAKE_C_FLAGS_DEBUG} /MDd")

    # Release 빌드
    set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} /MD")
    set(CMAKE_C_FLAGS_RELEASE "${CMAKE_C_FLAGS_RELEASE} /MD")

    # 반복자 디버그 레벨 설정
    add_compile_definitions(
        $<$<CONFIG:Debug>:_ITERATOR_DEBUG_LEVEL=2>
        $<$<CONFIG:Release>:_ITERATOR_DEBUG_LEVEL=0>
    )
endif()

(빌드)
 cmake -G "Visual Studio 16 2019" ..
 cmake --build . --config Debug
