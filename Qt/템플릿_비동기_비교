<템플릿>

void MainWindow::rotateImage()
{
    applyImageProcessing(&ImageProcessor::rotateImage, currentImage);
}

template<typename Func, typename ...Args>
inline void MainWindow::applyImageProcessing(Func func, Args&& ...args)
{
    if (!currentImage.empty()) {
        auto future = (imageProcessor->*func)(std::forward<Args>(args)...);
        future.waitForFinished();
        if (!future.result()) {
            qDebug() << "Failed to apply" << Q_FUNC_INFO;
        }
    }
    else {
        qDebug() << "No image to process.";
    }
}

<비동기식처리>
void MainWindow::rotateImage()
{
    QtConcurrent::run([this]() {
        if (!currentImage.empty()) {
            imageProcessor->rotateImage(currentImage);
        }
    });
}

<비교>
1. 템플릿 함수 사용
-장점: 함수 호출을 추상화 하여 코드의 중복성을 줄일 수 있음
-단점: 모든 이미지 처리 함수가 동기적으로 실행됨. 
한 함수의 처리가 끝날때 까지 UI가 블록 될 수 있음. 따라서 대용량 이미지나 시간이
오래 걸리는 작업에서는 UI가 응답하지 않는 현상이 발생할 수 있음.

2. 비동기 사용(QtConcurrent::run)
-장점: 각 이미지 처리 함수가 별도의 스레드에서 비동기적으로 실행되므로 UI가 블록되지
않음. 대용량 이미지나 시간이 오래 걸리는 작업에서도 UI가 응답 상태를 유지할 수 있음.
-단점: 각 함수마다 비동기 처리를 위하 코드를 추가해야 하므로 코드의 중복이 발생할 
수 있음.
